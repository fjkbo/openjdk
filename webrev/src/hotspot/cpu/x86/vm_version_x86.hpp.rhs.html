<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre></pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef CPU_X86_VM_VERSION_X86_HPP
  26 #define CPU_X86_VM_VERSION_X86_HPP
  27 
  28 #include "runtime/globals_extension.hpp"
  29 #include "runtime/vm_version.hpp"
  30 
  31 class VM_Version : public Abstract_VM_Version {
  32   friend class VMStructs;
  33   friend class JVMCIVMStructs;
  34 
  35  public:
  36   // cpuid result register layouts.  These are all unions of a uint32_t
  37   // (in case anyone wants access to the register as a whole) and a bitfield.
  38 
  39   union StdCpuid1Eax {
  40     uint32_t value;
  41     struct {
  42       uint32_t stepping   : 4,
  43                model      : 4,
  44                family     : 4,
  45                proc_type  : 2,
  46                           : 2,
  47                ext_model  : 4,
  48                ext_family : 8,
  49                           : 4;
  50     } bits;
  51   };
  52 
  53   union StdCpuid1Ebx { // example, unused
  54     uint32_t value;
  55     struct {
  56       uint32_t brand_id         : 8,
  57                clflush_size     : 8,
  58                threads_per_cpu  : 8,
  59                apic_id          : 8;
  60     } bits;
  61   };
  62 
  63   union StdCpuid1Ecx {
  64     uint32_t value;
  65     struct {
  66       uint32_t sse3     : 1,
  67                clmul    : 1,
  68                         : 1,
  69                monitor  : 1,
  70                         : 1,
  71                vmx      : 1,
  72                         : 1,
  73                est      : 1,
  74                         : 1,
  75                ssse3    : 1,
  76                cid      : 1,
  77                         : 1,
  78                fma      : 1,
  79                cmpxchg16: 1,
  80                         : 4,
  81                dca      : 1,
  82                sse4_1   : 1,
  83                sse4_2   : 1,
  84                         : 2,
  85                popcnt   : 1,
  86                         : 1,
  87                aes      : 1,
  88                         : 1,
  89                osxsave  : 1,
  90                avx      : 1,
  91                         : 3;
  92     } bits;
  93   };
  94 
  95   union StdCpuid1Edx {
  96     uint32_t value;
  97     struct {
  98       uint32_t          : 4,
  99                tsc      : 1,
 100                         : 3,
 101                cmpxchg8 : 1,
 102                         : 6,
 103                cmov     : 1,
 104                         : 3,
 105                clflush  : 1,
 106                         : 3,
 107                mmx      : 1,
 108                fxsr     : 1,
 109                sse      : 1,
 110                sse2     : 1,
 111                         : 1,
 112                ht       : 1,
 113                         : 3;
 114     } bits;
 115   };
 116 
 117   union DcpCpuid4Eax {
 118     uint32_t value;
 119     struct {
 120       uint32_t cache_type    : 5,
 121                              : 21,
 122                cores_per_cpu : 6;
 123     } bits;
 124   };
 125 
 126   union DcpCpuid4Ebx {
 127     uint32_t value;
 128     struct {
 129       uint32_t L1_line_size  : 12,
 130                partitions    : 10,
 131                associativity : 10;
 132     } bits;
 133   };
 134 
 135   union TplCpuidBEbx {
 136     uint32_t value;
 137     struct {
 138       uint32_t logical_cpus : 16,
 139                             : 16;
 140     } bits;
 141   };
 142 
 143   union ExtCpuid1Ecx {
 144     uint32_t value;
 145     struct {
 146       uint32_t LahfSahf     : 1,
 147                CmpLegacy    : 1,
 148                             : 3,
 149                lzcnt_intel  : 1,
 150                lzcnt        : 1,
 151                sse4a        : 1,
 152                misalignsse  : 1,
 153                prefetchw    : 1,
 154                             : 22;
 155     } bits;
 156   };
 157 
 158   union ExtCpuid1Edx {
 159     uint32_t value;
 160     struct {
 161       uint32_t           : 22,
 162                mmx_amd   : 1,
 163                mmx       : 1,
 164                fxsr      : 1,
 165                          : 4,
 166                long_mode : 1,
 167                tdnow2    : 1,
 168                tdnow     : 1;
 169     } bits;
 170   };
 171 
 172   union ExtCpuid5Ex {
 173     uint32_t value;
 174     struct {
 175       uint32_t L1_line_size : 8,
 176                L1_tag_lines : 8,
 177                L1_assoc     : 8,
 178                L1_size      : 8;
 179     } bits;
 180   };
 181 
 182   union ExtCpuid7Edx {
 183     uint32_t value;
 184     struct {
 185       uint32_t               : 8,
 186               tsc_invariance : 1,
 187                              : 23;
 188     } bits;
 189   };
 190 
 191   union ExtCpuid8Ecx {
 192     uint32_t value;
 193     struct {
 194       uint32_t cores_per_cpu : 8,
 195                              : 24;
 196     } bits;
 197   };
 198 
 199   union SefCpuid7Eax {
 200     uint32_t value;
 201   };
 202 
 203   union SefCpuid7Ebx {
 204     uint32_t value;
 205     struct {
 206       uint32_t fsgsbase : 1,
 207                         : 2,
 208                    bmi1 : 1,
 209                         : 1,
 210                    avx2 : 1,
 211                         : 2,
 212                    bmi2 : 1,
 213                    erms : 1,
 214                         : 1,
 215                     rtm : 1,
 216                         : 4,
 217                 avx512f : 1,
 218                avx512dq : 1,
 219                         : 1,
 220                     adx : 1,
 221                         : 6,
 222                avx512pf : 1,
 223                avx512er : 1,
 224                avx512cd : 1,
 225                     sha : 1,
 226                avx512bw : 1,
 227                avx512vl : 1;
 228     } bits;
 229   };
 230 
 231   union SefCpuid7Ecx {
 232     uint32_t value;
 233     struct {
 234       uint32_t prefetchwt1 : 1,
 235                avx512_vbmi : 1,
 236                       umip : 1,
 237                        pku : 1,
 238                      ospke : 1,
 239                            : 1,
 240               avx512_vbmi2 : 1,
 241                            : 1,
 242                       gfni : 1,
 243                       vaes : 1,
 244                 vpclmulqdq : 1,
 245                avx512_vnni : 1,
 246              avx512_bitalg : 1,
 247                            : 1,
 248           avx512_vpopcntdq : 1,
 249                            : 17;
 250     } bits;
 251   };
 252 
 253   union SefCpuid7Edx {
 254     uint32_t value;
 255     struct {
 256       uint32_t             : 2,
 257              avx512_4vnniw : 1,
 258              avx512_4fmaps : 1,
 259                            : 28;
 260     } bits;
 261   };
 262 
 263   union ExtCpuid1EEbx {
 264     uint32_t value;
 265     struct {
 266       uint32_t                  : 8,
 267                threads_per_core : 8,
 268                                 : 16;
 269     } bits;
 270   };
 271 
 272   union XemXcr0Eax {
 273     uint32_t value;
 274     struct {
 275       uint32_t x87     : 1,
 276                sse     : 1,
 277                ymm     : 1,
 278                bndregs : 1,
 279                bndcsr  : 1,
 280                opmask  : 1,
 281                zmm512  : 1,
 282                zmm32   : 1,
 283                        : 24;
 284     } bits;
 285   };
 286 
 287 protected:
 288   static int _cpu;
 289   static int _model;
 290   static int _stepping;
 291 
 292   static address   _cpuinfo_segv_addr; // address of instruction which causes SEGV
 293   static address   _cpuinfo_cont_addr; // address of instruction after the one which causes SEGV
 294 
 295   enum Feature_Flag {
 296     CPU_CX8      = (1 &lt;&lt; 0), // next bits are from cpuid 1 (EDX)
 297     CPU_CMOV     = (1 &lt;&lt; 1),
 298     CPU_FXSR     = (1 &lt;&lt; 2),
 299     CPU_HT       = (1 &lt;&lt; 3),
 300     CPU_MMX      = (1 &lt;&lt; 4),
 301     CPU_3DNOW_PREFETCH = (1 &lt;&lt; 5), // Processor supports 3dnow prefetch and prefetchw instructions
 302                                    // may not necessarily support other 3dnow instructions
 303     CPU_SSE      = (1 &lt;&lt; 6),
 304     CPU_SSE2     = (1 &lt;&lt; 7),
 305     CPU_SSE3     = (1 &lt;&lt; 8),  // SSE3 comes from cpuid 1 (ECX)
 306     CPU_SSSE3    = (1 &lt;&lt; 9),
 307     CPU_SSE4A    = (1 &lt;&lt; 10),
 308     CPU_SSE4_1   = (1 &lt;&lt; 11),
 309     CPU_SSE4_2   = (1 &lt;&lt; 12),
 310     CPU_POPCNT   = (1 &lt;&lt; 13),
 311     CPU_LZCNT    = (1 &lt;&lt; 14),
 312     CPU_TSC      = (1 &lt;&lt; 15),
 313     CPU_TSCINV   = (1 &lt;&lt; 16),
 314     CPU_AVX      = (1 &lt;&lt; 17),
 315     CPU_AVX2     = (1 &lt;&lt; 18),
 316     CPU_AES      = (1 &lt;&lt; 19),
 317     CPU_ERMS     = (1 &lt;&lt; 20), // enhanced 'rep movsb/stosb' instructions
 318     CPU_CLMUL    = (1 &lt;&lt; 21), // carryless multiply for CRC
 319     CPU_BMI1     = (1 &lt;&lt; 22),
 320     CPU_BMI2     = (1 &lt;&lt; 23),
 321     CPU_RTM      = (1 &lt;&lt; 24), // Restricted Transactional Memory instructions
 322     CPU_ADX      = (1 &lt;&lt; 25),
 323     CPU_AVX512F  = (1 &lt;&lt; 26), // AVX 512bit foundation instructions
 324     CPU_AVX512DQ = (1 &lt;&lt; 27),
 325     CPU_AVX512PF = (1 &lt;&lt; 28),
 326     CPU_AVX512ER = (1 &lt;&lt; 29),
 327     CPU_AVX512CD = (1 &lt;&lt; 30)
 328     // Keeping sign bit 31 unassigned.
 329   };
 330 
 331 #define CPU_AVX512BW ((uint64_t)UCONST64(0x100000000)) // enums are limited to 31 bit
 332 #define CPU_AVX512VL ((uint64_t)UCONST64(0x200000000)) // EVEX instructions with smaller vector length
 333 #define CPU_SHA ((uint64_t)UCONST64(0x400000000))      // SHA instructions
 334 #define CPU_FMA ((uint64_t)UCONST64(0x800000000))      // FMA instructions
 335 #define CPU_VZEROUPPER ((uint64_t)UCONST64(0x1000000000))       // Vzeroupper instruction
 336 #define CPU_AVX512_VPOPCNTDQ ((uint64_t)UCONST64(0x2000000000)) // Vector popcount
 337 #define CPU_VPCLMULQDQ ((uint64_t)UCONST64(0x4000000000)) //Vector carryless multiplication
 338 #define CPU_VAES ((uint64_t)UCONST64(0x8000000000))    // Vector AES instructions
 339 #define CPU_VNNI ((uint64_t)UCONST64(0x16000000000))   // Vector Neural Network Instructions
 340 
 341   enum Extended_Family {
 342     // AMD
 343     CPU_FAMILY_AMD_11H       = 0x11,
 344     // ZX
 345     CPU_FAMILY_ZX_CORE_F6    = 6,
 346     CPU_FAMILY_ZX_CORE_F7    = 7,
 347     // Intel
 348     CPU_FAMILY_INTEL_CORE    = 6,
 349     CPU_MODEL_NEHALEM        = 0x1e,
 350     CPU_MODEL_NEHALEM_EP     = 0x1a,
 351     CPU_MODEL_NEHALEM_EX     = 0x2e,
 352     CPU_MODEL_WESTMERE       = 0x25,
 353     CPU_MODEL_WESTMERE_EP    = 0x2c,
 354     CPU_MODEL_WESTMERE_EX    = 0x2f,
 355     CPU_MODEL_SANDYBRIDGE    = 0x2a,
 356     CPU_MODEL_SANDYBRIDGE_EP = 0x2d,
 357     CPU_MODEL_IVYBRIDGE_EP   = 0x3a,
 358     CPU_MODEL_HASWELL_E3     = 0x3c,
 359     CPU_MODEL_HASWELL_E7     = 0x3f,
 360     CPU_MODEL_BROADWELL      = 0x3d,
 361     CPU_MODEL_SKYLAKE        = CPU_MODEL_HASWELL_E3
 362   };
 363 
 364   // cpuid information block.  All info derived from executing cpuid with
 365   // various function numbers is stored here.  Intel and AMD info is
 366   // merged in this block: accessor methods disentangle it.
 367   //
 368   // The info block is laid out in subblocks of 4 dwords corresponding to
 369   // eax, ebx, ecx and edx, whether or not they contain anything useful.
 370   struct CpuidInfo {
 371     // cpuid function 0
 372     uint32_t std_max_function;
 373     uint32_t std_vendor_name_0;
 374     uint32_t std_vendor_name_1;
 375     uint32_t std_vendor_name_2;
 376 
 377     // cpuid function 1
 378     StdCpuid1Eax std_cpuid1_eax;
 379     StdCpuid1Ebx std_cpuid1_ebx;
 380     StdCpuid1Ecx std_cpuid1_ecx;
 381     StdCpuid1Edx std_cpuid1_edx;
 382 
 383     // cpuid function 4 (deterministic cache parameters)
 384     DcpCpuid4Eax dcp_cpuid4_eax;
 385     DcpCpuid4Ebx dcp_cpuid4_ebx;
 386     uint32_t     dcp_cpuid4_ecx; // unused currently
 387     uint32_t     dcp_cpuid4_edx; // unused currently
 388 
 389     // cpuid function 7 (structured extended features)
 390     SefCpuid7Eax sef_cpuid7_eax;
 391     SefCpuid7Ebx sef_cpuid7_ebx;
 392     SefCpuid7Ecx sef_cpuid7_ecx;
 393     SefCpuid7Edx sef_cpuid7_edx;
 394 
 395     // cpuid function 0xB (processor topology)
 396     // ecx = 0
 397     uint32_t     tpl_cpuidB0_eax;
 398     TplCpuidBEbx tpl_cpuidB0_ebx;
 399     uint32_t     tpl_cpuidB0_ecx; // unused currently
 400     uint32_t     tpl_cpuidB0_edx; // unused currently
 401 
 402     // ecx = 1
 403     uint32_t     tpl_cpuidB1_eax;
 404     TplCpuidBEbx tpl_cpuidB1_ebx;
 405     uint32_t     tpl_cpuidB1_ecx; // unused currently
 406     uint32_t     tpl_cpuidB1_edx; // unused currently
 407 
 408     // ecx = 2
 409     uint32_t     tpl_cpuidB2_eax;
 410     TplCpuidBEbx tpl_cpuidB2_ebx;
 411     uint32_t     tpl_cpuidB2_ecx; // unused currently
 412     uint32_t     tpl_cpuidB2_edx; // unused currently
 413 
 414     // cpuid function 0x80000000 // example, unused
 415     uint32_t ext_max_function;
 416     uint32_t ext_vendor_name_0;
 417     uint32_t ext_vendor_name_1;
 418     uint32_t ext_vendor_name_2;
 419 
 420     // cpuid function 0x80000001
 421     uint32_t     ext_cpuid1_eax; // reserved
 422     uint32_t     ext_cpuid1_ebx; // reserved
 423     ExtCpuid1Ecx ext_cpuid1_ecx;
 424     ExtCpuid1Edx ext_cpuid1_edx;
 425 
 426     // cpuid functions 0x80000002 thru 0x80000004: example, unused
 427     uint32_t proc_name_0, proc_name_1, proc_name_2, proc_name_3;
 428     uint32_t proc_name_4, proc_name_5, proc_name_6, proc_name_7;
 429     uint32_t proc_name_8, proc_name_9, proc_name_10,proc_name_11;
 430 
 431     // cpuid function 0x80000005 // AMD L1, Intel reserved
 432     uint32_t     ext_cpuid5_eax; // unused currently
 433     uint32_t     ext_cpuid5_ebx; // reserved
 434     ExtCpuid5Ex  ext_cpuid5_ecx; // L1 data cache info (AMD)
 435     ExtCpuid5Ex  ext_cpuid5_edx; // L1 instruction cache info (AMD)
 436 
 437     // cpuid function 0x80000007
 438     uint32_t     ext_cpuid7_eax; // reserved
 439     uint32_t     ext_cpuid7_ebx; // reserved
 440     uint32_t     ext_cpuid7_ecx; // reserved
 441     ExtCpuid7Edx ext_cpuid7_edx; // tscinv
 442 
 443     // cpuid function 0x80000008
 444     uint32_t     ext_cpuid8_eax; // unused currently
 445     uint32_t     ext_cpuid8_ebx; // reserved
 446     ExtCpuid8Ecx ext_cpuid8_ecx;
 447     uint32_t     ext_cpuid8_edx; // reserved
 448 
 449     // cpuid function 0x8000001E // AMD 17h
 450     uint32_t      ext_cpuid1E_eax;
 451     ExtCpuid1EEbx ext_cpuid1E_ebx; // threads per core (AMD17h)
 452     uint32_t      ext_cpuid1E_ecx;
 453     uint32_t      ext_cpuid1E_edx; // unused currently
 454 
 455     // extended control register XCR0 (the XFEATURE_ENABLED_MASK register)
 456     XemXcr0Eax   xem_xcr0_eax;
 457     uint32_t     xem_xcr0_edx; // reserved
 458 
 459     // Space to save ymm registers after signal handle
 460     int          ymm_save[8*4]; // Save ymm0, ymm7, ymm8, ymm15
 461 
 462     // Space to save zmm registers after signal handle
 463     int          zmm_save[16*4]; // Save zmm0, zmm7, zmm8, zmm31
 464   };
 465 
 466   // The actual cpuid info block
 467   static CpuidInfo _cpuid_info;
 468 
 469   // Extractors and predicates
 470   static uint32_t extended_cpu_family() {
 471     uint32_t result = _cpuid_info.std_cpuid1_eax.bits.family;
 472     result += _cpuid_info.std_cpuid1_eax.bits.ext_family;
 473     return result;
 474   }
 475 
 476   static uint32_t extended_cpu_model() {
 477     uint32_t result = _cpuid_info.std_cpuid1_eax.bits.model;
 478     result |= _cpuid_info.std_cpuid1_eax.bits.ext_model &lt;&lt; 4;
 479     return result;
 480   }
 481 
 482   static uint32_t cpu_stepping() {
 483     uint32_t result = _cpuid_info.std_cpuid1_eax.bits.stepping;
 484     return result;
 485   }
 486 
 487   static uint logical_processor_count() {
 488     uint result = threads_per_core();
 489     return result;
 490   }
 491 
 492   static uint64_t feature_flags() {
 493     uint64_t result = 0;
 494     if (_cpuid_info.std_cpuid1_edx.bits.cmpxchg8 != 0)
 495       result |= CPU_CX8;
 496     if (_cpuid_info.std_cpuid1_edx.bits.cmov != 0)
 497       result |= CPU_CMOV;
<a name="1" id="anc1"></a><span class="changed"> 498     if (_cpuid_info.std_cpuid1_edx.bits.fxsr != 0 || ((is_amd() || is_hygon()) &amp;&amp;</span>
 499         _cpuid_info.ext_cpuid1_edx.bits.fxsr != 0))
 500       result |= CPU_FXSR;
 501     // HT flag is set for multi-core processors also.
 502     if (threads_per_core() &gt; 1)
 503       result |= CPU_HT;
<a name="2" id="anc2"></a><span class="changed"> 504     if (_cpuid_info.std_cpuid1_edx.bits.mmx != 0 || ( (is_amd() || is_hygon()) &amp;&amp;</span>
 505         _cpuid_info.ext_cpuid1_edx.bits.mmx != 0))
 506       result |= CPU_MMX;
 507     if (_cpuid_info.std_cpuid1_edx.bits.sse != 0)
 508       result |= CPU_SSE;
 509     if (_cpuid_info.std_cpuid1_edx.bits.sse2 != 0)
 510       result |= CPU_SSE2;
 511     if (_cpuid_info.std_cpuid1_ecx.bits.sse3 != 0)
 512       result |= CPU_SSE3;
 513     if (_cpuid_info.std_cpuid1_ecx.bits.ssse3 != 0)
 514       result |= CPU_SSSE3;
 515     if (_cpuid_info.std_cpuid1_ecx.bits.sse4_1 != 0)
 516       result |= CPU_SSE4_1;
 517     if (_cpuid_info.std_cpuid1_ecx.bits.sse4_2 != 0)
 518       result |= CPU_SSE4_2;
 519     if (_cpuid_info.std_cpuid1_ecx.bits.popcnt != 0)
 520       result |= CPU_POPCNT;
 521     if (_cpuid_info.std_cpuid1_ecx.bits.avx != 0 &amp;&amp;
 522         _cpuid_info.std_cpuid1_ecx.bits.osxsave != 0 &amp;&amp;
 523         _cpuid_info.xem_xcr0_eax.bits.sse != 0 &amp;&amp;
 524         _cpuid_info.xem_xcr0_eax.bits.ymm != 0) {
 525       result |= CPU_AVX;
 526       result |= CPU_VZEROUPPER;
 527       if (_cpuid_info.sef_cpuid7_ebx.bits.avx2 != 0)
 528         result |= CPU_AVX2;
 529       if (_cpuid_info.sef_cpuid7_ebx.bits.avx512f != 0 &amp;&amp;
 530           _cpuid_info.xem_xcr0_eax.bits.opmask != 0 &amp;&amp;
 531           _cpuid_info.xem_xcr0_eax.bits.zmm512 != 0 &amp;&amp;
 532           _cpuid_info.xem_xcr0_eax.bits.zmm32 != 0) {
 533         result |= CPU_AVX512F;
 534         if (_cpuid_info.sef_cpuid7_ebx.bits.avx512cd != 0)
 535           result |= CPU_AVX512CD;
 536         if (_cpuid_info.sef_cpuid7_ebx.bits.avx512dq != 0)
 537           result |= CPU_AVX512DQ;
 538         if (_cpuid_info.sef_cpuid7_ebx.bits.avx512pf != 0)
 539           result |= CPU_AVX512PF;
 540         if (_cpuid_info.sef_cpuid7_ebx.bits.avx512er != 0)
 541           result |= CPU_AVX512ER;
 542         if (_cpuid_info.sef_cpuid7_ebx.bits.avx512bw != 0)
 543           result |= CPU_AVX512BW;
 544         if (_cpuid_info.sef_cpuid7_ebx.bits.avx512vl != 0)
 545           result |= CPU_AVX512VL;
 546         if (_cpuid_info.sef_cpuid7_ecx.bits.avx512_vpopcntdq != 0)
 547           result |= CPU_AVX512_VPOPCNTDQ;
 548         if (_cpuid_info.sef_cpuid7_ecx.bits.vpclmulqdq != 0)
 549           result |= CPU_VPCLMULQDQ;
 550         if (_cpuid_info.sef_cpuid7_ecx.bits.vaes != 0)
 551           result |= CPU_VAES;
 552         if (_cpuid_info.sef_cpuid7_ecx.bits.avx512_vnni != 0)
 553           result |= CPU_VNNI;
 554       }
 555     }
 556     if(_cpuid_info.sef_cpuid7_ebx.bits.bmi1 != 0)
 557       result |= CPU_BMI1;
 558     if (_cpuid_info.std_cpuid1_edx.bits.tsc != 0)
 559       result |= CPU_TSC;
 560     if (_cpuid_info.ext_cpuid7_edx.bits.tsc_invariance != 0)
 561       result |= CPU_TSCINV;
 562     if (_cpuid_info.std_cpuid1_ecx.bits.aes != 0)
 563       result |= CPU_AES;
 564     if (_cpuid_info.sef_cpuid7_ebx.bits.erms != 0)
 565       result |= CPU_ERMS;
 566     if (_cpuid_info.std_cpuid1_ecx.bits.clmul != 0)
 567       result |= CPU_CLMUL;
 568     if (_cpuid_info.sef_cpuid7_ebx.bits.rtm != 0)
 569       result |= CPU_RTM;
 570     if(_cpuid_info.sef_cpuid7_ebx.bits.adx != 0)
 571        result |= CPU_ADX;
 572     if(_cpuid_info.sef_cpuid7_ebx.bits.bmi2 != 0)
 573       result |= CPU_BMI2;
 574     if (_cpuid_info.sef_cpuid7_ebx.bits.sha != 0)
 575       result |= CPU_SHA;
 576     if (_cpuid_info.std_cpuid1_ecx.bits.fma != 0)
 577       result |= CPU_FMA;
 578 
<a name="3" id="anc3"></a><span class="changed"> 579     // AMD|Hygon features.</span>
<span class="changed"> 580     if (is_amd() || is_hygon()) {</span>
 581       if ((_cpuid_info.ext_cpuid1_edx.bits.tdnow != 0) ||
 582           (_cpuid_info.ext_cpuid1_ecx.bits.prefetchw != 0))
 583         result |= CPU_3DNOW_PREFETCH;
 584       if (_cpuid_info.ext_cpuid1_ecx.bits.lzcnt != 0)
 585         result |= CPU_LZCNT;
 586       if (_cpuid_info.ext_cpuid1_ecx.bits.sse4a != 0)
 587         result |= CPU_SSE4A;
 588     }
 589     // Intel features.
 590     if(is_intel()) {
 591       if(_cpuid_info.ext_cpuid1_ecx.bits.lzcnt_intel != 0)
 592         result |= CPU_LZCNT;
 593       // for Intel, ecx.bits.misalignsse bit (bit 8) indicates support for prefetchw
 594       if (_cpuid_info.ext_cpuid1_ecx.bits.misalignsse != 0) {
 595         result |= CPU_3DNOW_PREFETCH;
 596       }
 597     }
 598 
 599     // ZX features.
 600     if (is_zx()) {
 601       if (_cpuid_info.ext_cpuid1_ecx.bits.lzcnt_intel != 0)
 602         result |= CPU_LZCNT;
 603       // for ZX, ecx.bits.misalignsse bit (bit 8) indicates support for prefetchw
 604       if (_cpuid_info.ext_cpuid1_ecx.bits.misalignsse != 0) {
 605         result |= CPU_3DNOW_PREFETCH;
 606       }
 607     }
 608 
 609     return result;
 610   }
 611 
 612   static bool os_supports_avx_vectors() {
 613     bool retVal = false;
 614     int nreg = 2 LP64_ONLY(+2);
 615     if (supports_evex()) {
 616       // Verify that OS save/restore all bits of EVEX registers
 617       // during signal processing.
 618       retVal = true;
 619       for (int i = 0; i &lt; 16 * nreg; i++) { // 64 bytes per zmm register
 620         if (_cpuid_info.zmm_save[i] != ymm_test_value()) {
 621           retVal = false;
 622           break;
 623         }
 624       }
 625     } else if (supports_avx()) {
 626       // Verify that OS save/restore all bits of AVX registers
 627       // during signal processing.
 628       retVal = true;
 629       for (int i = 0; i &lt; 8 * nreg; i++) { // 32 bytes per ymm register
 630         if (_cpuid_info.ymm_save[i] != ymm_test_value()) {
 631           retVal = false;
 632           break;
 633         }
 634       }
 635       // zmm_save will be set on a EVEX enabled machine even if we choose AVX code gen
 636       if (retVal == false) {
 637         // Verify that OS save/restore all bits of EVEX registers
 638         // during signal processing.
 639         retVal = true;
 640         for (int i = 0; i &lt; 16 * nreg; i++) { // 64 bytes per zmm register
 641           if (_cpuid_info.zmm_save[i] != ymm_test_value()) {
 642             retVal = false;
 643             break;
 644           }
 645         }
 646       }
 647     }
 648     return retVal;
 649   }
 650 
 651   static void get_processor_features();
 652 
 653 public:
 654   // Offsets for cpuid asm stub
 655   static ByteSize std_cpuid0_offset() { return byte_offset_of(CpuidInfo, std_max_function); }
 656   static ByteSize std_cpuid1_offset() { return byte_offset_of(CpuidInfo, std_cpuid1_eax); }
 657   static ByteSize dcp_cpuid4_offset() { return byte_offset_of(CpuidInfo, dcp_cpuid4_eax); }
 658   static ByteSize sef_cpuid7_offset() { return byte_offset_of(CpuidInfo, sef_cpuid7_eax); }
 659   static ByteSize ext_cpuid1_offset() { return byte_offset_of(CpuidInfo, ext_cpuid1_eax); }
 660   static ByteSize ext_cpuid5_offset() { return byte_offset_of(CpuidInfo, ext_cpuid5_eax); }
 661   static ByteSize ext_cpuid7_offset() { return byte_offset_of(CpuidInfo, ext_cpuid7_eax); }
 662   static ByteSize ext_cpuid8_offset() { return byte_offset_of(CpuidInfo, ext_cpuid8_eax); }
 663   static ByteSize ext_cpuid1E_offset() { return byte_offset_of(CpuidInfo, ext_cpuid1E_eax); }
 664   static ByteSize tpl_cpuidB0_offset() { return byte_offset_of(CpuidInfo, tpl_cpuidB0_eax); }
 665   static ByteSize tpl_cpuidB1_offset() { return byte_offset_of(CpuidInfo, tpl_cpuidB1_eax); }
 666   static ByteSize tpl_cpuidB2_offset() { return byte_offset_of(CpuidInfo, tpl_cpuidB2_eax); }
 667   static ByteSize xem_xcr0_offset() { return byte_offset_of(CpuidInfo, xem_xcr0_eax); }
 668   static ByteSize ymm_save_offset() { return byte_offset_of(CpuidInfo, ymm_save); }
 669   static ByteSize zmm_save_offset() { return byte_offset_of(CpuidInfo, zmm_save); }
 670 
 671   // The value used to check ymm register after signal handle
 672   static int ymm_test_value()    { return 0xCAFEBABE; }
 673 
 674   static void get_cpu_info_wrapper();
 675   static void set_cpuinfo_segv_addr(address pc) { _cpuinfo_segv_addr = pc; }
 676   static bool  is_cpuinfo_segv_addr(address pc) { return _cpuinfo_segv_addr == pc; }
 677   static void set_cpuinfo_cont_addr(address pc) { _cpuinfo_cont_addr = pc; }
 678   static address  cpuinfo_cont_addr()           { return _cpuinfo_cont_addr; }
 679 
 680   static void clean_cpuFeatures()   { _features = 0; }
 681   static void set_avx_cpuFeatures() { _features = (CPU_SSE | CPU_SSE2 | CPU_AVX | CPU_VZEROUPPER ); }
 682   static void set_evex_cpuFeatures() { _features = (CPU_AVX512F | CPU_SSE | CPU_SSE2 | CPU_VZEROUPPER ); }
 683 
 684 
 685   // Initialization
 686   static void initialize();
 687 
 688   // Override Abstract_VM_Version implementation
 689   static bool use_biased_locking();
 690 
 691   // Asserts
 692   static void assert_is_initialized() {
 693     assert(_cpuid_info.std_cpuid1_eax.bits.family != 0, "VM_Version not initialized");
 694   }
 695 
 696   //
 697   // Processor family:
 698   //       3   -  386
 699   //       4   -  486
 700   //       5   -  Pentium
 701   //       6   -  PentiumPro, Pentium II, Celeron, Xeon, Pentium III, Athlon,
 702   //              Pentium M, Core Solo, Core Duo, Core2 Duo
 703   //    family 6 model:   9,        13,       14,        15
 704   //    0x0f   -  Pentium 4, Opteron
 705   //
 706   // Note: The cpu family should be used to select between
 707   //       instruction sequences which are valid on all Intel
 708   //       processors.  Use the feature test functions below to
 709   //       determine whether a particular instruction is supported.
 710   //
 711   static int  cpu_family()        { return _cpu;}
 712   static bool is_P6()             { return cpu_family() &gt;= 6; }
 713   static bool is_amd()            { assert_is_initialized(); return _cpuid_info.std_vendor_name_0 == 0x68747541; } // 'htuA'
<a name="4" id="anc4"></a><span class="new"> 714   static bool is_hygon()          { assert_is_initialized(); return _cpuid_info.std_vendor_name_0 == 0x6F677948; } // 'ogyH'</span>
 715   static bool is_intel()          { assert_is_initialized(); return _cpuid_info.std_vendor_name_0 == 0x756e6547; } // 'uneG'
 716   static bool is_zx()             { assert_is_initialized(); return (_cpuid_info.std_vendor_name_0 == 0x746e6543) || (_cpuid_info.std_vendor_name_0 == 0x68532020); } // 'tneC'||'hS  '
 717   static bool is_atom_family()    { return ((cpu_family() == 0x06) &amp;&amp; ((extended_cpu_model() == 0x36) || (extended_cpu_model() == 0x37) || (extended_cpu_model() == 0x4D))); } //Silvermont and Centerton
 718   static bool is_knights_family() { return ((cpu_family() == 0x06) &amp;&amp; ((extended_cpu_model() == 0x57) || (extended_cpu_model() == 0x85))); } // Xeon Phi 3200/5200/7200 and Future Xeon Phi
 719 
 720   static bool supports_processor_topology() {
 721     return (_cpuid_info.std_max_function &gt;= 0xB) &amp;&amp;
 722            // eax[4:0] | ebx[0:15] == 0 indicates invalid topology level.
 723            // Some cpus have max cpuid &gt;= 0xB but do not support processor topology.
 724            (((_cpuid_info.tpl_cpuidB0_eax &amp; 0x1f) | _cpuid_info.tpl_cpuidB0_ebx.bits.logical_cpus) != 0);
 725   }
 726 
 727   static uint cores_per_cpu()  {
 728     uint result = 1;
 729     if (is_intel()) {
 730       bool supports_topology = supports_processor_topology();
 731       if (supports_topology) {
 732         result = _cpuid_info.tpl_cpuidB1_ebx.bits.logical_cpus /
 733                  _cpuid_info.tpl_cpuidB0_ebx.bits.logical_cpus;
 734       }
 735       if (!supports_topology || result == 0) {
 736         result = (_cpuid_info.dcp_cpuid4_eax.bits.cores_per_cpu + 1);
 737       }
<a name="5" id="anc5"></a><span class="changed"> 738     } else if (is_amd() || is_hygon()) {</span>
 739       result = (_cpuid_info.ext_cpuid8_ecx.bits.cores_per_cpu + 1);
 740     } else if (is_zx()) {
 741       bool supports_topology = supports_processor_topology();
 742       if (supports_topology) {
 743         result = _cpuid_info.tpl_cpuidB1_ebx.bits.logical_cpus /
 744                  _cpuid_info.tpl_cpuidB0_ebx.bits.logical_cpus;
 745       }
 746       if (!supports_topology || result == 0) {
 747         result = (_cpuid_info.dcp_cpuid4_eax.bits.cores_per_cpu + 1);
 748       }
 749     }
 750     return result;
 751   }
 752 
 753   static uint threads_per_core()  {
 754     uint result = 1;
 755     if (is_intel() &amp;&amp; supports_processor_topology()) {
 756       result = _cpuid_info.tpl_cpuidB0_ebx.bits.logical_cpus;
 757     } else if (is_zx() &amp;&amp; supports_processor_topology()) {
 758       result = _cpuid_info.tpl_cpuidB0_ebx.bits.logical_cpus;
 759     } else if (_cpuid_info.std_cpuid1_edx.bits.ht != 0) {
 760       if (cpu_family() &gt;= 0x17) {
 761         result = _cpuid_info.ext_cpuid1E_ebx.bits.threads_per_core + 1;
 762       } else {
 763         result = _cpuid_info.std_cpuid1_ebx.bits.threads_per_cpu /
 764                  cores_per_cpu();
 765       }
 766     }
 767     return (result == 0 ? 1 : result);
 768   }
 769 
 770   static intx L1_line_size()  {
 771     intx result = 0;
 772     if (is_intel()) {
 773       result = (_cpuid_info.dcp_cpuid4_ebx.bits.L1_line_size + 1);
<a name="6" id="anc6"></a><span class="changed"> 774     } else if (is_amd() || is_hygon()) {</span>
 775       result = _cpuid_info.ext_cpuid5_ecx.bits.L1_line_size;
 776     } else if (is_zx()) {
 777       result = (_cpuid_info.dcp_cpuid4_ebx.bits.L1_line_size + 1);
 778     }
 779     if (result &lt; 32) // not defined ?
 780       result = 32;   // 32 bytes by default on x86 and other x64
 781     return result;
 782   }
 783 
 784   static intx prefetch_data_size()  {
 785     return L1_line_size();
 786   }
 787 
 788   //
 789   // Feature identification
 790   //
 791   static bool supports_cpuid()    { return _features  != 0; }
 792   static bool supports_cmpxchg8() { return (_features &amp; CPU_CX8) != 0; }
 793   static bool supports_cmov()     { return (_features &amp; CPU_CMOV) != 0; }
 794   static bool supports_fxsr()     { return (_features &amp; CPU_FXSR) != 0; }
 795   static bool supports_ht()       { return (_features &amp; CPU_HT) != 0; }
 796   static bool supports_mmx()      { return (_features &amp; CPU_MMX) != 0; }
 797   static bool supports_sse()      { return (_features &amp; CPU_SSE) != 0; }
 798   static bool supports_sse2()     { return (_features &amp; CPU_SSE2) != 0; }
 799   static bool supports_sse3()     { return (_features &amp; CPU_SSE3) != 0; }
 800   static bool supports_ssse3()    { return (_features &amp; CPU_SSSE3)!= 0; }
 801   static bool supports_sse4_1()   { return (_features &amp; CPU_SSE4_1) != 0; }
 802   static bool supports_sse4_2()   { return (_features &amp; CPU_SSE4_2) != 0; }
 803   static bool supports_popcnt()   { return (_features &amp; CPU_POPCNT) != 0; }
 804   static bool supports_avx()      { return (_features &amp; CPU_AVX) != 0; }
 805   static bool supports_avx2()     { return (_features &amp; CPU_AVX2) != 0; }
 806   static bool supports_tsc()      { return (_features &amp; CPU_TSC)    != 0; }
 807   static bool supports_aes()      { return (_features &amp; CPU_AES) != 0; }
 808   static bool supports_erms()     { return (_features &amp; CPU_ERMS) != 0; }
 809   static bool supports_clmul()    { return (_features &amp; CPU_CLMUL) != 0; }
 810   static bool supports_rtm()      { return (_features &amp; CPU_RTM) != 0; }
 811   static bool supports_bmi1()     { return (_features &amp; CPU_BMI1) != 0; }
 812   static bool supports_bmi2()     { return (_features &amp; CPU_BMI2) != 0; }
 813   static bool supports_adx()      { return (_features &amp; CPU_ADX) != 0; }
 814   static bool supports_evex()     { return (_features &amp; CPU_AVX512F) != 0; }
 815   static bool supports_avx512dq() { return (_features &amp; CPU_AVX512DQ) != 0; }
 816   static bool supports_avx512pf() { return (_features &amp; CPU_AVX512PF) != 0; }
 817   static bool supports_avx512er() { return (_features &amp; CPU_AVX512ER) != 0; }
 818   static bool supports_avx512cd() { return (_features &amp; CPU_AVX512CD) != 0; }
 819   static bool supports_avx512bw() { return (_features &amp; CPU_AVX512BW) != 0; }
 820   static bool supports_avx512vl() { return (_features &amp; CPU_AVX512VL) != 0; }
 821   static bool supports_avx512vlbw() { return (supports_evex() &amp;&amp; supports_avx512bw() &amp;&amp; supports_avx512vl()); }
 822   static bool supports_avx512vldq() { return (supports_evex() &amp;&amp; supports_avx512dq() &amp;&amp; supports_avx512vl()); }
 823   static bool supports_avx512vlbwdq() { return (supports_evex() &amp;&amp; supports_avx512vl() &amp;&amp;
 824                                                 supports_avx512bw() &amp;&amp; supports_avx512dq()); }
 825   static bool supports_avx512novl() { return (supports_evex() &amp;&amp; !supports_avx512vl()); }
 826   static bool supports_avx512nobw() { return (supports_evex() &amp;&amp; !supports_avx512bw()); }
 827   static bool supports_avx256only() { return (supports_avx2() &amp;&amp; !supports_evex()); }
 828   static bool supports_avxonly()    { return ((supports_avx2() || supports_avx()) &amp;&amp; !supports_evex()); }
 829   static bool supports_sha()        { return (_features &amp; CPU_SHA) != 0; }
 830   static bool supports_fma()        { return (_features &amp; CPU_FMA) != 0 &amp;&amp; supports_avx(); }
 831   static bool supports_vzeroupper() { return (_features &amp; CPU_VZEROUPPER) != 0; }
 832   static bool supports_vpopcntdq()  { return (_features &amp; CPU_AVX512_VPOPCNTDQ) != 0; }
 833   static bool supports_vpclmulqdq() { return (_features &amp; CPU_VPCLMULQDQ) != 0; }
 834   static bool supports_vaes()       { return (_features &amp; CPU_VAES) != 0; }
 835   static bool supports_vnni()       { return (_features &amp; CPU_VNNI) != 0; }
 836 
 837   // Intel features
 838   static bool is_intel_family_core() { return is_intel() &amp;&amp;
 839                                        extended_cpu_family() == CPU_FAMILY_INTEL_CORE; }
 840 
 841   static bool is_intel_tsc_synched_at_init()  {
 842     if (is_intel_family_core()) {
 843       uint32_t ext_model = extended_cpu_model();
 844       if (ext_model == CPU_MODEL_NEHALEM_EP     ||
 845           ext_model == CPU_MODEL_WESTMERE_EP    ||
 846           ext_model == CPU_MODEL_SANDYBRIDGE_EP ||
 847           ext_model == CPU_MODEL_IVYBRIDGE_EP) {
 848         // &lt;= 2-socket invariant tsc support. EX versions are usually used
 849         // in &gt; 2-socket systems and likely don't synchronize tscs at
 850         // initialization.
 851         // Code that uses tsc values must be prepared for them to arbitrarily
 852         // jump forward or backward.
 853         return true;
 854       }
 855     }
 856     return false;
 857   }
 858 
 859   // AMD features
 860   static bool supports_3dnow_prefetch()    { return (_features &amp; CPU_3DNOW_PREFETCH) != 0; }
<a name="7" id="anc7"></a><span class="changed"> 861   static bool supports_mmx_ext()  { return (is_amd()||is_hygon()) &amp;&amp; _cpuid_info.ext_cpuid1_edx.bits.mmx_amd != 0; }</span>
 862   static bool supports_lzcnt()    { return (_features &amp; CPU_LZCNT) != 0; }
 863   static bool supports_sse4a()    { return (_features &amp; CPU_SSE4A) != 0; }
 864 
 865   static bool is_amd_Barcelona()  { return is_amd() &amp;&amp;
 866                                            extended_cpu_family() == CPU_FAMILY_AMD_11H; }
 867 
 868   // Intel and AMD newer cores support fast timestamps well
 869   static bool supports_tscinv_bit() {
 870     return (_features &amp; CPU_TSCINV) != 0;
 871   }
 872   static bool supports_tscinv() {
 873     return supports_tscinv_bit() &amp;&amp;
<a name="8" id="anc8"></a><span class="changed"> 874            ( ((is_amd()||is_hygon()) &amp;&amp; !is_amd_Barcelona()) ||</span>
 875              is_intel_tsc_synched_at_init() );
 876   }
 877 
 878   // Intel Core and newer cpus have fast IDIV instruction (excluding Atom).
 879   static bool has_fast_idiv()     { return is_intel() &amp;&amp; cpu_family() == 6 &amp;&amp;
 880                                            supports_sse3() &amp;&amp; _model != 0x1C; }
 881 
 882   static bool supports_compare_and_exchange() { return true; }
 883 
 884   static intx allocate_prefetch_distance(bool use_watermark_prefetch) {
 885     // Hardware prefetching (distance/size in bytes):
 886     // Pentium 3 -  64 /  32
 887     // Pentium 4 - 256 / 128
 888     // Athlon    -  64 /  32 ????
 889     // Opteron   - 128 /  64 only when 2 sequential cache lines accessed
 890     // Core      - 128 /  64
 891     //
 892     // Software prefetching (distance in bytes / instruction with best score):
 893     // Pentium 3 - 128 / prefetchnta
 894     // Pentium 4 - 512 / prefetchnta
 895     // Athlon    - 128 / prefetchnta
 896     // Opteron   - 256 / prefetchnta
 897     // Core      - 256 / prefetchnta
 898     // It will be used only when AllocatePrefetchStyle &gt; 0
 899 
<a name="9" id="anc9"></a><span class="changed"> 900     if (is_amd() || is_hygon()) { // AMD</span>
 901       if (supports_sse2()) {
 902         return 256; // Opteron
 903       } else {
 904         return 128; // Athlon
 905       }
 906     } else { // Intel
 907       if (supports_sse3() &amp;&amp; cpu_family() == 6) {
 908         if (supports_sse4_2() &amp;&amp; supports_ht()) { // Nehalem based cpus
 909           return 192;
 910         } else if (use_watermark_prefetch) { // watermark prefetching on Core
 911 #ifdef _LP64
 912           return 384;
 913 #else
 914           return 320;
 915 #endif
 916         }
 917       }
 918       if (supports_sse2()) {
 919         if (cpu_family() == 6) {
 920           return 256; // Pentium M, Core, Core2
 921         } else {
 922           return 512; // Pentium 4
 923         }
 924       } else {
 925         return 128; // Pentium 3 (and all other old CPUs)
 926       }
 927     }
 928   }
 929 
 930   // SSE2 and later processors implement a 'pause' instruction
 931   // that can be used for efficient implementation of
 932   // the intrinsic for java.lang.Thread.onSpinWait()
 933   static bool supports_on_spin_wait() { return supports_sse2(); }
 934 };
 935 
 936 #endif // CPU_X86_VM_VERSION_X86_HPP
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="10" type="hidden" /></form></body></html>
