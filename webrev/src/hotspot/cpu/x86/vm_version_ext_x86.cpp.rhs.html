<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre></pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include "precompiled.hpp"
  26 #include "jvm.h"
  27 #include "utilities/macros.hpp"
  28 #include "asm/macroAssembler.hpp"
  29 #include "asm/macroAssembler.inline.hpp"
  30 #include "memory/allocation.inline.hpp"
  31 #include "memory/resourceArea.hpp"
  32 #include "runtime/java.hpp"
  33 #include "runtime/stubCodeGenerator.hpp"
  34 #include "vm_version_ext_x86.hpp"
  35 
  36 typedef enum {
  37    CPU_FAMILY_8086_8088  = 0,
  38    CPU_FAMILY_INTEL_286  = 2,
  39    CPU_FAMILY_INTEL_386  = 3,
  40    CPU_FAMILY_INTEL_486  = 4,
  41    CPU_FAMILY_PENTIUM    = 5,
  42    CPU_FAMILY_PENTIUMPRO = 6,    // Same family several models
  43    CPU_FAMILY_PENTIUM_4  = 0xF
  44 } FamilyFlag;
  45 
  46  typedef enum {
  47     RDTSCP_FLAG  = 0x08000000, // bit 27
  48     INTEL64_FLAG = 0x20000000  // bit 29
  49   } _featureExtendedEdxFlag;
  50 
  51 #define CPUID_STANDARD_FN   0x0
  52 #define CPUID_STANDARD_FN_1 0x1
  53 #define CPUID_STANDARD_FN_4 0x4
  54 #define CPUID_STANDARD_FN_B 0xb
  55 
  56 #define CPUID_EXTENDED_FN   0x80000000
  57 #define CPUID_EXTENDED_FN_1 0x80000001
  58 #define CPUID_EXTENDED_FN_2 0x80000002
  59 #define CPUID_EXTENDED_FN_3 0x80000003
  60 #define CPUID_EXTENDED_FN_4 0x80000004
  61 #define CPUID_EXTENDED_FN_7 0x80000007
  62 #define CPUID_EXTENDED_FN_8 0x80000008
  63 
  64 typedef enum {
  65    FPU_FLAG     = 0x00000001,
  66    VME_FLAG     = 0x00000002,
  67    DE_FLAG      = 0x00000004,
  68    PSE_FLAG     = 0x00000008,
  69    TSC_FLAG     = 0x00000010,
  70    MSR_FLAG     = 0x00000020,
  71    PAE_FLAG     = 0x00000040,
  72    MCE_FLAG     = 0x00000080,
  73    CX8_FLAG     = 0x00000100,
  74    APIC_FLAG    = 0x00000200,
  75    SEP_FLAG     = 0x00000800,
  76    MTRR_FLAG    = 0x00001000,
  77    PGE_FLAG     = 0x00002000,
  78    MCA_FLAG     = 0x00004000,
  79    CMOV_FLAG    = 0x00008000,
  80    PAT_FLAG     = 0x00010000,
  81    PSE36_FLAG   = 0x00020000,
  82    PSNUM_FLAG   = 0x00040000,
  83    CLFLUSH_FLAG = 0x00080000,
  84    DTS_FLAG     = 0x00200000,
  85    ACPI_FLAG    = 0x00400000,
  86    MMX_FLAG     = 0x00800000,
  87    FXSR_FLAG    = 0x01000000,
  88    SSE_FLAG     = 0x02000000,
  89    SSE2_FLAG    = 0x04000000,
  90    SS_FLAG      = 0x08000000,
  91    HTT_FLAG     = 0x10000000,
  92    TM_FLAG      = 0x20000000
  93 } FeatureEdxFlag;
  94 
  95 static BufferBlob* cpuid_brand_string_stub_blob;
  96 static const int   cpuid_brand_string_stub_size = 550;
  97 
  98 extern "C" {
  99   typedef void (*getCPUIDBrandString_stub_t)(void*);
 100 }
 101 
 102 static getCPUIDBrandString_stub_t getCPUIDBrandString_stub = NULL;
 103 
 104 class VM_Version_Ext_StubGenerator: public StubCodeGenerator {
 105  public:
 106 
 107   VM_Version_Ext_StubGenerator(CodeBuffer *c) : StubCodeGenerator(c) {}
 108 
 109   address generate_getCPUIDBrandString(void) {
 110     // Flags to test CPU type.
 111     const uint32_t HS_EFL_AC           = 0x40000;
 112     const uint32_t HS_EFL_ID           = 0x200000;
 113     // Values for when we don't have a CPUID instruction.
 114     const int      CPU_FAMILY_SHIFT = 8;
 115     const uint32_t CPU_FAMILY_386   = (3 &lt;&lt; CPU_FAMILY_SHIFT);
 116     const uint32_t CPU_FAMILY_486   = (4 &lt;&lt; CPU_FAMILY_SHIFT);
 117 
 118     Label detect_486, cpu486, detect_586, done, ext_cpuid;
 119 
 120     StubCodeMark mark(this, "VM_Version_Ext", "getCPUIDNameInfo_stub");
 121 #   define __ _masm-&gt;
 122 
 123     address start = __ pc();
 124 
 125     //
 126     // void getCPUIDBrandString(VM_Version::CpuidInfo* cpuid_info);
 127     //
 128     // LP64: rcx and rdx are first and second argument registers on windows
 129 
 130     __ push(rbp);
 131 #ifdef _LP64
 132     __ mov(rbp, c_rarg0); // cpuid_info address
 133 #else
 134     __ movptr(rbp, Address(rsp, 8)); // cpuid_info address
 135 #endif
 136     __ push(rbx);
 137     __ push(rsi);
 138     __ pushf();          // preserve rbx, and flags
 139     __ pop(rax);
 140     __ push(rax);
 141     __ mov(rcx, rax);
 142     //
 143     // if we are unable to change the AC flag, we have a 386
 144     //
 145     __ xorl(rax, HS_EFL_AC);
 146     __ push(rax);
 147     __ popf();
 148     __ pushf();
 149     __ pop(rax);
 150     __ cmpptr(rax, rcx);
 151     __ jccb(Assembler::notEqual, detect_486);
 152 
 153     __ movl(rax, CPU_FAMILY_386);
 154     __ jmp(done);
 155 
 156     //
 157     // If we are unable to change the ID flag, we have a 486 which does
 158     // not support the "cpuid" instruction.
 159     //
 160     __ bind(detect_486);
 161     __ mov(rax, rcx);
 162     __ xorl(rax, HS_EFL_ID);
 163     __ push(rax);
 164     __ popf();
 165     __ pushf();
 166     __ pop(rax);
 167     __ cmpptr(rcx, rax);
 168     __ jccb(Assembler::notEqual, detect_586);
 169 
 170     __ bind(cpu486);
 171     __ movl(rax, CPU_FAMILY_486);
 172     __ jmp(done);
 173 
 174     //
 175     // At this point, we have a chip which supports the "cpuid" instruction
 176     //
 177     __ bind(detect_586);
 178     __ xorl(rax, rax);
 179     __ cpuid();
 180     __ orl(rax, rax);
 181     __ jcc(Assembler::equal, cpu486);   // if cpuid doesn't support an input
 182                                         // value of at least 1, we give up and
 183                                         // assume a 486
 184 
 185     //
 186     // Extended cpuid(0x80000000) for processor brand string detection
 187     //
 188     __ bind(ext_cpuid);
 189     __ movl(rax, CPUID_EXTENDED_FN);
 190     __ cpuid();
 191     __ cmpl(rax, CPUID_EXTENDED_FN_4);
 192     __ jcc(Assembler::below, done);
 193 
 194     //
 195     // Extended cpuid(0x80000002)  // first 16 bytes in brand string
 196     //
 197     __ movl(rax, CPUID_EXTENDED_FN_2);
 198     __ cpuid();
 199     __ lea(rsi, Address(rbp, in_bytes(VM_Version_Ext::proc_name_0_offset())));
 200     __ movl(Address(rsi, 0), rax);
 201     __ lea(rsi, Address(rbp, in_bytes(VM_Version_Ext::proc_name_1_offset())));
 202     __ movl(Address(rsi, 0), rbx);
 203     __ lea(rsi, Address(rbp, in_bytes(VM_Version_Ext::proc_name_2_offset())));
 204     __ movl(Address(rsi, 0), rcx);
 205     __ lea(rsi, Address(rbp, in_bytes(VM_Version_Ext::proc_name_3_offset())));
 206     __ movl(Address(rsi,0), rdx);
 207 
 208     //
 209     // Extended cpuid(0x80000003) // next 16 bytes in brand string
 210     //
 211     __ movl(rax, CPUID_EXTENDED_FN_3);
 212     __ cpuid();
 213     __ lea(rsi, Address(rbp, in_bytes(VM_Version_Ext::proc_name_4_offset())));
 214     __ movl(Address(rsi, 0), rax);
 215     __ lea(rsi, Address(rbp, in_bytes(VM_Version_Ext::proc_name_5_offset())));
 216     __ movl(Address(rsi, 0), rbx);
 217     __ lea(rsi, Address(rbp, in_bytes(VM_Version_Ext::proc_name_6_offset())));
 218     __ movl(Address(rsi, 0), rcx);
 219     __ lea(rsi, Address(rbp, in_bytes(VM_Version_Ext::proc_name_7_offset())));
 220     __ movl(Address(rsi,0), rdx);
 221 
 222     //
 223     // Extended cpuid(0x80000004) // last 16 bytes in brand string
 224     //
 225     __ movl(rax, CPUID_EXTENDED_FN_4);
 226     __ cpuid();
 227     __ lea(rsi, Address(rbp, in_bytes(VM_Version_Ext::proc_name_8_offset())));
 228     __ movl(Address(rsi, 0), rax);
 229     __ lea(rsi, Address(rbp, in_bytes(VM_Version_Ext::proc_name_9_offset())));
 230     __ movl(Address(rsi, 0), rbx);
 231     __ lea(rsi, Address(rbp, in_bytes(VM_Version_Ext::proc_name_10_offset())));
 232     __ movl(Address(rsi, 0), rcx);
 233     __ lea(rsi, Address(rbp, in_bytes(VM_Version_Ext::proc_name_11_offset())));
 234     __ movl(Address(rsi,0), rdx);
 235 
 236     //
 237     // return
 238     //
 239     __ bind(done);
 240     __ popf();
 241     __ pop(rsi);
 242     __ pop(rbx);
 243     __ pop(rbp);
 244     __ ret(0);
 245 
 246 #   undef __
 247 
 248     return start;
 249   };
 250 };
 251 
 252 
 253 // VM_Version_Ext statics
 254 const size_t VM_Version_Ext::VENDOR_LENGTH = 13;
 255 const size_t VM_Version_Ext::CPU_EBS_MAX_LENGTH = (3 * 4 * 4 + 1);
 256 const size_t VM_Version_Ext::CPU_TYPE_DESC_BUF_SIZE = 256;
 257 const size_t VM_Version_Ext::CPU_DETAILED_DESC_BUF_SIZE = 4096;
 258 char* VM_Version_Ext::_cpu_brand_string = NULL;
 259 jlong VM_Version_Ext::_max_qualified_cpu_frequency = 0;
 260 
 261 int VM_Version_Ext::_no_of_threads = 0;
 262 int VM_Version_Ext::_no_of_cores = 0;
 263 int VM_Version_Ext::_no_of_packages = 0;
 264 
 265 void VM_Version_Ext::initialize(void) {
 266   ResourceMark rm;
 267 
 268   cpuid_brand_string_stub_blob = BufferBlob::create("getCPUIDBrandString_stub", cpuid_brand_string_stub_size);
 269   if (cpuid_brand_string_stub_blob == NULL) {
 270     vm_exit_during_initialization("Unable to allocate getCPUIDBrandString_stub");
 271   }
 272   CodeBuffer c(cpuid_brand_string_stub_blob);
 273   VM_Version_Ext_StubGenerator g(&amp;c);
 274   getCPUIDBrandString_stub = CAST_TO_FN_PTR(getCPUIDBrandString_stub_t,
 275                                    g.generate_getCPUIDBrandString());
 276 }
 277 
 278 const char* VM_Version_Ext::cpu_model_description(void) {
 279   uint32_t cpu_family = extended_cpu_family();
 280   uint32_t cpu_model = extended_cpu_model();
 281   const char* model = NULL;
 282 
 283   if (cpu_family == CPU_FAMILY_PENTIUMPRO) {
 284     for (uint32_t i = 0; i &lt;= cpu_model; i++) {
 285       model = _model_id_pentium_pro[i];
 286       if (model == NULL) {
 287         break;
 288       }
 289     }
 290   }
 291   return model;
 292 }
 293 
 294 const char* VM_Version_Ext::cpu_brand_string(void) {
 295   if (_cpu_brand_string == NULL) {
 296     _cpu_brand_string = NEW_C_HEAP_ARRAY_RETURN_NULL(char, CPU_EBS_MAX_LENGTH, mtInternal);
 297     if (NULL == _cpu_brand_string) {
 298       return NULL;
 299     }
 300     int ret_val = cpu_extended_brand_string(_cpu_brand_string, CPU_EBS_MAX_LENGTH);
 301     if (ret_val != OS_OK) {
 302       FREE_C_HEAP_ARRAY(char, _cpu_brand_string);
 303       _cpu_brand_string = NULL;
 304     }
 305   }
 306   return _cpu_brand_string;
 307 }
 308 
 309 const char* VM_Version_Ext::cpu_brand(void) {
 310   const char*  brand  = NULL;
 311 
 312   if ((_cpuid_info.std_cpuid1_ebx.value &amp; 0xFF) &gt; 0) {
 313     int brand_num = _cpuid_info.std_cpuid1_ebx.value &amp; 0xFF;
 314     brand = _brand_id[0];
 315     for (int i = 0; brand != NULL &amp;&amp; i &lt;= brand_num; i += 1) {
 316       brand = _brand_id[i];
 317     }
 318   }
 319   return brand;
 320 }
 321 
 322 bool VM_Version_Ext::cpu_is_em64t(void) {
 323   return ((_cpuid_info.ext_cpuid1_edx.value &amp; INTEL64_FLAG) == INTEL64_FLAG);
 324 }
 325 
 326 bool VM_Version_Ext::is_netburst(void) {
 327   return (is_intel() &amp;&amp; (extended_cpu_family() == CPU_FAMILY_PENTIUM_4));
 328 }
 329 
 330 bool VM_Version_Ext::supports_tscinv_ext(void) {
 331   if (!supports_tscinv_bit()) {
 332     return false;
 333   }
 334 
 335   if (is_intel()) {
 336     return true;
 337   }
 338 
 339   if (is_amd()) {
 340     return !is_amd_Barcelona();
 341   }
 342 
<a name="1" id="anc1"></a><span class="new"> 343   if (is_hygon()) {</span>
<span class="new"> 344     return true;</span>
<span class="new"> 345   }</span>
<span class="new"> 346 </span>
 347   return false;
 348 }
 349 
 350 void VM_Version_Ext::resolve_cpu_information_details(void) {
 351 
 352   // in future we want to base this information on proper cpu
 353   // and cache topology enumeration such as:
 354   // Intel 64 Architecture Processor Topology Enumeration
 355   // which supports system cpu and cache topology enumeration
 356   // either using 2xAPICIDs or initial APICIDs
 357 
 358   // currently only rough cpu information estimates
 359   // which will not necessarily reflect the exact configuration of the system
 360 
 361   // this is the number of logical hardware threads
 362   // visible to the operating system
 363   _no_of_threads = os::processor_count();
 364 
 365   // find out number of threads per cpu package
 366   int threads_per_package = threads_per_core() * cores_per_cpu();
 367 
 368   // use amount of threads visible to the process in order to guess number of sockets
 369   _no_of_packages = _no_of_threads / threads_per_package;
 370 
 371   // process might only see a subset of the total number of threads
 372   // from a single processor package. Virtualization/resource management for example.
 373   // If so then just write a hard 1 as num of pkgs.
 374   if (0 == _no_of_packages) {
 375     _no_of_packages = 1;
 376   }
 377 
 378   // estimate the number of cores
 379   _no_of_cores = cores_per_cpu() * _no_of_packages;
 380 }
 381 
 382 int VM_Version_Ext::number_of_threads(void) {
 383   if (_no_of_threads == 0) {
 384    resolve_cpu_information_details();
 385   }
 386   return _no_of_threads;
 387 }
 388 
 389 int VM_Version_Ext::number_of_cores(void) {
 390   if (_no_of_cores == 0) {
 391     resolve_cpu_information_details();
 392   }
 393   return _no_of_cores;
 394 }
 395 
 396 int VM_Version_Ext::number_of_sockets(void) {
 397   if (_no_of_packages == 0) {
 398     resolve_cpu_information_details();
 399   }
 400   return _no_of_packages;
 401 }
 402 
 403 const char* VM_Version_Ext::cpu_family_description(void) {
 404   int cpu_family_id = extended_cpu_family();
 405   if (is_amd()) {
 406     return _family_id_amd[cpu_family_id];
 407   }
 408   if (is_intel()) {
 409     if (cpu_family_id == CPU_FAMILY_PENTIUMPRO) {
 410       return cpu_model_description();
 411     }
 412     return _family_id_intel[cpu_family_id];
 413   }
 414   return "Unknown x86";
 415 }
 416 
 417 int VM_Version_Ext::cpu_type_description(char* const buf, size_t buf_len) {
 418   assert(buf != NULL, "buffer is NULL!");
 419   assert(buf_len &gt;= CPU_TYPE_DESC_BUF_SIZE, "buffer len should at least be == CPU_TYPE_DESC_BUF_SIZE!");
 420 
 421   const char* cpu_type = NULL;
 422   const char* x64 = NULL;
 423 
 424   if (is_intel()) {
 425     cpu_type = "Intel";
 426     x64 = cpu_is_em64t() ? " Intel64" : "";
 427   } else if (is_amd()) {
 428     cpu_type = "AMD";
 429     x64 = cpu_is_em64t() ? " AMD64" : "";
 430   } else {
 431     cpu_type = "Unknown x86";
 432     x64 = cpu_is_em64t() ? " x86_64" : "";
 433   }
 434 
 435   jio_snprintf(buf, buf_len, "%s %s%s SSE SSE2%s%s%s%s%s%s%s%s",
 436     cpu_type,
 437     cpu_family_description(),
 438     supports_ht() ? " (HT)" : "",
 439     supports_sse3() ? " SSE3" : "",
 440     supports_ssse3() ? " SSSE3" : "",
 441     supports_sse4_1() ? " SSE4.1" : "",
 442     supports_sse4_2() ? " SSE4.2" : "",
 443     supports_sse4a() ? " SSE4A" : "",
 444     is_netburst() ? " Netburst" : "",
 445     is_intel_family_core() ? " Core" : "",
 446     x64);
 447 
 448   return OS_OK;
 449 }
 450 
 451 int VM_Version_Ext::cpu_extended_brand_string(char* const buf, size_t buf_len) {
 452   assert(buf != NULL, "buffer is NULL!");
 453   assert(buf_len &gt;= CPU_EBS_MAX_LENGTH, "buffer len should at least be == CPU_EBS_MAX_LENGTH!");
 454   assert(getCPUIDBrandString_stub != NULL, "not initialized");
 455 
 456   // invoke newly generated asm code to fetch CPU Brand String
 457   getCPUIDBrandString_stub(&amp;_cpuid_info);
 458 
 459   // fetch results into buffer
 460   *((uint32_t*) &amp;buf[0])  = _cpuid_info.proc_name_0;
 461   *((uint32_t*) &amp;buf[4])  = _cpuid_info.proc_name_1;
 462   *((uint32_t*) &amp;buf[8])  = _cpuid_info.proc_name_2;
 463   *((uint32_t*) &amp;buf[12]) = _cpuid_info.proc_name_3;
 464   *((uint32_t*) &amp;buf[16]) = _cpuid_info.proc_name_4;
 465   *((uint32_t*) &amp;buf[20]) = _cpuid_info.proc_name_5;
 466   *((uint32_t*) &amp;buf[24]) = _cpuid_info.proc_name_6;
 467   *((uint32_t*) &amp;buf[28]) = _cpuid_info.proc_name_7;
 468   *((uint32_t*) &amp;buf[32]) = _cpuid_info.proc_name_8;
 469   *((uint32_t*) &amp;buf[36]) = _cpuid_info.proc_name_9;
 470   *((uint32_t*) &amp;buf[40]) = _cpuid_info.proc_name_10;
 471   *((uint32_t*) &amp;buf[44]) = _cpuid_info.proc_name_11;
 472 
 473   return OS_OK;
 474 }
 475 
 476 size_t VM_Version_Ext::cpu_write_support_string(char* const buf, size_t buf_len) {
 477   guarantee(buf != NULL, "buffer is NULL!");
 478   guarantee(buf_len &gt; 0, "buffer len not enough!");
 479 
 480   unsigned int flag = 0;
 481   unsigned int fi = 0;
 482   size_t       written = 0;
 483   const char*  prefix = "";
 484 
 485 #define WRITE_TO_BUF(string)                                                          \
 486   {                                                                                   \
 487     int res = jio_snprintf(&amp;buf[written], buf_len - written, "%s%s", prefix, string); \
 488     if (res &lt; 0) {                                                                    \
 489       return buf_len - 1;                                                             \
 490     }                                                                                 \
 491     written += res;                                                                   \
 492     if (prefix[0] == '\0') {                                                          \
 493       prefix = ", ";                                                                  \
 494     }                                                                                 \
 495   }
 496 
 497   for (flag = 1, fi = 0; flag &lt;= 0x20000000 ; flag &lt;&lt;= 1, fi++) {
 498     if (flag == HTT_FLAG &amp;&amp; (((_cpuid_info.std_cpuid1_ebx.value &gt;&gt; 16) &amp; 0xff) &lt;= 1)) {
 499       continue; /* no hyperthreading */
 500     } else if (flag == SEP_FLAG &amp;&amp; (cpu_family() == CPU_FAMILY_PENTIUMPRO &amp;&amp; ((_cpuid_info.std_cpuid1_eax.value &amp; 0xff) &lt; 0x33))) {
 501       continue; /* no fast system call */
 502     }
 503     if ((_cpuid_info.std_cpuid1_edx.value &amp; flag) &amp;&amp; strlen(_feature_edx_id[fi]) &gt; 0) {
 504       WRITE_TO_BUF(_feature_edx_id[fi]);
 505     }
 506   }
 507 
 508   for (flag = 1, fi = 0; flag &lt;= 0x20000000; flag &lt;&lt;= 1, fi++) {
 509     if ((_cpuid_info.std_cpuid1_ecx.value &amp; flag) &amp;&amp; strlen(_feature_ecx_id[fi]) &gt; 0) {
 510       WRITE_TO_BUF(_feature_ecx_id[fi]);
 511     }
 512   }
 513 
 514   for (flag = 1, fi = 0; flag &lt;= 0x20000000 ; flag &lt;&lt;= 1, fi++) {
 515     if ((_cpuid_info.ext_cpuid1_ecx.value &amp; flag) &amp;&amp; strlen(_feature_extended_ecx_id[fi]) &gt; 0) {
 516       WRITE_TO_BUF(_feature_extended_ecx_id[fi]);
 517     }
 518   }
 519 
 520   for (flag = 1, fi = 0; flag &lt;= 0x20000000; flag &lt;&lt;= 1, fi++) {
 521     if ((_cpuid_info.ext_cpuid1_edx.value &amp; flag) &amp;&amp; strlen(_feature_extended_edx_id[fi]) &gt; 0) {
 522       WRITE_TO_BUF(_feature_extended_edx_id[fi]);
 523     }
 524   }
 525 
 526   if (supports_tscinv_bit()) {
 527       WRITE_TO_BUF("Invariant TSC");
 528   }
 529 
 530   return written;
 531 }
 532 
 533 /**
 534  * Write a detailed description of the cpu to a given buffer, including
 535  * feature set.
 536  */
 537 int VM_Version_Ext::cpu_detailed_description(char* const buf, size_t buf_len) {
 538   assert(buf != NULL, "buffer is NULL!");
 539   assert(buf_len &gt;= CPU_DETAILED_DESC_BUF_SIZE, "buffer len should at least be == CPU_DETAILED_DESC_BUF_SIZE!");
 540 
 541   static const char* unknown = "&lt;unknown&gt;";
 542   char               vendor_id[VENDOR_LENGTH];
 543   const char*        family = NULL;
 544   const char*        model = NULL;
 545   const char*        brand = NULL;
 546   int                outputLen = 0;
 547 
 548   family = cpu_family_description();
 549   if (family == NULL) {
 550     family = unknown;
 551   }
 552 
 553   model = cpu_model_description();
 554   if (model == NULL) {
 555     model = unknown;
 556   }
 557 
 558   brand = cpu_brand_string();
 559 
 560   if (brand == NULL) {
 561     brand = cpu_brand();
 562     if (brand == NULL) {
 563       brand = unknown;
 564     }
 565   }
 566 
 567   *((uint32_t*) &amp;vendor_id[0]) = _cpuid_info.std_vendor_name_0;
 568   *((uint32_t*) &amp;vendor_id[4]) = _cpuid_info.std_vendor_name_2;
 569   *((uint32_t*) &amp;vendor_id[8]) = _cpuid_info.std_vendor_name_1;
 570   vendor_id[VENDOR_LENGTH-1] = '\0';
 571 
 572   outputLen = jio_snprintf(buf, buf_len, "Brand: %s, Vendor: %s\n"
 573     "Family: %s (0x%x), Model: %s (0x%x), Stepping: 0x%x\n"
 574     "Ext. family: 0x%x, Ext. model: 0x%x, Type: 0x%x, Signature: 0x%8.8x\n"
 575     "Features: ebx: 0x%8.8x, ecx: 0x%8.8x, edx: 0x%8.8x\n"
 576     "Ext. features: eax: 0x%8.8x, ebx: 0x%8.8x, ecx: 0x%8.8x, edx: 0x%8.8x\n"
 577     "Supports: ",
 578     brand,
 579     vendor_id,
 580     family,
 581     extended_cpu_family(),
 582     model,
 583     extended_cpu_model(),
 584     cpu_stepping(),
 585     _cpuid_info.std_cpuid1_eax.bits.ext_family,
 586     _cpuid_info.std_cpuid1_eax.bits.ext_model,
 587     _cpuid_info.std_cpuid1_eax.bits.proc_type,
 588     _cpuid_info.std_cpuid1_eax.value,
 589     _cpuid_info.std_cpuid1_ebx.value,
 590     _cpuid_info.std_cpuid1_ecx.value,
 591     _cpuid_info.std_cpuid1_edx.value,
 592     _cpuid_info.ext_cpuid1_eax,
 593     _cpuid_info.ext_cpuid1_ebx,
 594     _cpuid_info.ext_cpuid1_ecx,
 595     _cpuid_info.ext_cpuid1_edx);
 596 
 597   if (outputLen &lt; 0 || (size_t) outputLen &gt;= buf_len - 1) {
 598     if (buf_len &gt; 0) { buf[buf_len-1] = '\0'; }
 599     return OS_ERR;
 600   }
 601 
 602   cpu_write_support_string(&amp;buf[outputLen], buf_len - outputLen);
 603 
 604   return OS_OK;
 605 }
 606 
 607 const char* VM_Version_Ext::cpu_name(void) {
 608   char cpu_type_desc[CPU_TYPE_DESC_BUF_SIZE];
 609   size_t cpu_desc_len = sizeof(cpu_type_desc);
 610 
 611   cpu_type_description(cpu_type_desc, cpu_desc_len);
 612   char* tmp = NEW_C_HEAP_ARRAY_RETURN_NULL(char, cpu_desc_len, mtTracing);
 613   if (NULL == tmp) {
 614     return NULL;
 615   }
 616   strncpy(tmp, cpu_type_desc, cpu_desc_len);
 617   return tmp;
 618 }
 619 
 620 const char* VM_Version_Ext::cpu_description(void) {
 621   char cpu_detailed_desc_buffer[CPU_DETAILED_DESC_BUF_SIZE];
 622   size_t cpu_detailed_desc_len = sizeof(cpu_detailed_desc_buffer);
 623 
 624   cpu_detailed_description(cpu_detailed_desc_buffer, cpu_detailed_desc_len);
 625 
 626   char* tmp = NEW_C_HEAP_ARRAY_RETURN_NULL(char, cpu_detailed_desc_len, mtTracing);
 627 
 628   if (NULL == tmp) {
 629     return NULL;
 630   }
 631 
 632   strncpy(tmp, cpu_detailed_desc_buffer, cpu_detailed_desc_len);
 633   return tmp;
 634 }
 635 
 636 /**
 637  *  See Intel Application note 485 (chapter 10) for details
 638  *  on frequency extraction from cpu brand string.
 639  *  http://www.intel.com/content/dam/www/public/us/en/documents/application-notes/processor-identification-cpuid-instruction-note.pdf
 640  *
 641  */
 642 jlong VM_Version_Ext::max_qualified_cpu_freq_from_brand_string(void) {
 643   // get brand string
 644   const char* const brand_string = cpu_brand_string();
 645   if (brand_string == NULL) {
 646     return 0;
 647   }
 648 
 649   const u8 MEGA = 1000000;
 650   u8 multiplier = 0;
 651   jlong frequency = 0;
 652 
 653   // the frequency information in the cpu brand string
 654   // is given in either of two formats "x.xxyHz" or "xxxxyHz",
 655   // where y=M,G,T and x is digits
 656   const char* Hz_location = strchr(brand_string, 'H');
 657 
 658   if (Hz_location != NULL) {
 659     if (*(Hz_location + 1) == 'z') {
 660       // switch on y in "yHz"
 661       switch(*(Hz_location - 1)) {
 662         case 'M' :
 663           // Set multiplier to frequency is in Hz
 664           multiplier = MEGA;
 665           break;
 666         case 'G' :
 667           multiplier = MEGA * 1000;
 668           break;
 669         case 'T' :
 670           multiplier = MEGA * 1000 * 1000;
 671           break;
 672       }
 673     }
 674   }
 675 
 676   if (multiplier &gt; 0) {
 677     // compute frequency (in Hz) from brand string
 678     if (*(Hz_location - 4) == '.') { // if format is "x.xx"
 679       frequency =  (jlong)(*(Hz_location - 5) - '0') * (multiplier);
 680       frequency += (jlong)(*(Hz_location - 3) - '0') * (multiplier / 10);
 681       frequency += (jlong)(*(Hz_location - 2) - '0') * (multiplier / 100);
 682     } else { // format is "xxxx"
 683       frequency =  (jlong)(*(Hz_location - 5) - '0') * 1000;
 684       frequency += (jlong)(*(Hz_location - 4) - '0') * 100;
 685       frequency += (jlong)(*(Hz_location - 3) - '0') * 10;
 686       frequency += (jlong)(*(Hz_location - 2) - '0');
 687       frequency *= multiplier;
 688     }
 689   }
 690   return frequency;
 691 }
 692 
 693 
 694 jlong VM_Version_Ext::maximum_qualified_cpu_frequency(void) {
 695   if (_max_qualified_cpu_frequency == 0) {
 696     _max_qualified_cpu_frequency = max_qualified_cpu_freq_from_brand_string();
 697   }
 698   return _max_qualified_cpu_frequency;
 699 }
 700 
 701 const char* const VM_Version_Ext::_family_id_intel[] = {
 702   "8086/8088",
 703   "",
 704   "286",
 705   "386",
 706   "486",
 707   "Pentium",
 708   "Pentium Pro",   //or Pentium-M/Woodcrest depeding on model
 709   "",
 710   "",
 711   "",
 712   "",
 713   "",
 714   "",
 715   "",
 716   "",
 717   "Pentium 4"
 718 };
 719 
 720 const char* const VM_Version_Ext::_family_id_amd[] = {
 721   "",
 722   "",
 723   "",
 724   "",
 725   "5x86",
 726   "K5/K6",
 727   "Athlon/AthlonXP",
 728   "",
 729   "",
 730   "",
 731   "",
 732   "",
 733   "",
 734   "",
 735   "",
 736   "Opteron/Athlon64",
 737   "Opteron QC/Phenom"  // Barcelona et.al.
 738 };
 739 // Partially from Intel 64 and IA-32 Architecture Software Developer's Manual,
 740 // September 2013, Vol 3C Table 35-1
 741 const char* const VM_Version_Ext::_model_id_pentium_pro[] = {
 742   "",
 743   "Pentium Pro",
 744   "",
 745   "Pentium II model 3",
 746   "",
 747   "Pentium II model 5/Xeon/Celeron",
 748   "Celeron",
 749   "Pentium III/Pentium III Xeon",
 750   "Pentium III/Pentium III Xeon",
 751   "Pentium M model 9",    // Yonah
 752   "Pentium III, model A",
 753   "Pentium III, model B",
 754   "",
 755   "Pentium M model D",    // Dothan
 756   "",
 757   "Core 2",               // 0xf Woodcrest/Conroe/Merom/Kentsfield/Clovertown
 758   "",
 759   "",
 760   "",
 761   "",
 762   "",
 763   "",
 764   "Celeron",              // 0x16 Celeron 65nm
 765   "Core 2",               // 0x17 Penryn / Harpertown
 766   "",
 767   "",
 768   "Core i7",              // 0x1A CPU_MODEL_NEHALEM_EP
 769   "Atom",                 // 0x1B Z5xx series Silverthorn
 770   "",
 771   "Core 2",               // 0x1D Dunnington (6-core)
 772   "Nehalem",              // 0x1E CPU_MODEL_NEHALEM
 773   "",
 774   "",
 775   "",
 776   "",
 777   "",
 778   "",
 779   "Westmere",             // 0x25 CPU_MODEL_WESTMERE
 780   "",
 781   "",
 782   "",                     // 0x28
 783   "",
 784   "Sandy Bridge",         // 0x2a "2nd Generation Intel Core i7, i5, i3"
 785   "",
 786   "Westmere-EP",          // 0x2c CPU_MODEL_WESTMERE_EP
 787   "Sandy Bridge-EP",      // 0x2d CPU_MODEL_SANDYBRIDGE_EP
 788   "Nehalem-EX",           // 0x2e CPU_MODEL_NEHALEM_EX
 789   "Westmere-EX",          // 0x2f CPU_MODEL_WESTMERE_EX
 790   "",
 791   "",
 792   "",
 793   "",
 794   "",
 795   "",
 796   "",
 797   "",
 798   "",
 799   "",
 800   "Ivy Bridge",           // 0x3a
 801   "",
 802   "Haswell",              // 0x3c "4th Generation Intel Core Processor"
 803   "",                     // 0x3d "Next Generation Intel Core Processor"
 804   "Ivy Bridge-EP",        // 0x3e "Next Generation Intel Xeon Processor E7 Family"
 805   "",                     // 0x3f "Future Generation Intel Xeon Processor"
 806   "",
 807   "",
 808   "",
 809   "",
 810   "",
 811   "Haswell",              // 0x45 "4th Generation Intel Core Processor"
 812   "Haswell",              // 0x46 "4th Generation Intel Core Processor"
 813   NULL
 814 };
 815 
 816 /* Brand ID is for back compability
 817  * Newer CPUs uses the extended brand string */
 818 const char* const VM_Version_Ext::_brand_id[] = {
 819   "",
 820   "Celeron processor",
 821   "Pentium III processor",
 822   "Intel Pentium III Xeon processor",
 823   "",
 824   "",
 825   "",
 826   "",
 827   "Intel Pentium 4 processor",
 828   NULL
 829 };
 830 
 831 
 832 const char* const VM_Version_Ext::_feature_edx_id[] = {
 833   "On-Chip FPU",
 834   "Virtual Mode Extensions",
 835   "Debugging Extensions",
 836   "Page Size Extensions",
 837   "Time Stamp Counter",
 838   "Model Specific Registers",
 839   "Physical Address Extension",
 840   "Machine Check Exceptions",
 841   "CMPXCHG8B Instruction",
 842   "On-Chip APIC",
 843   "",
 844   "Fast System Call",
 845   "Memory Type Range Registers",
 846   "Page Global Enable",
 847   "Machine Check Architecture",
 848   "Conditional Mov Instruction",
 849   "Page Attribute Table",
 850   "36-bit Page Size Extension",
 851   "Processor Serial Number",
 852   "CLFLUSH Instruction",
 853   "",
 854   "Debug Trace Store feature",
 855   "ACPI registers in MSR space",
 856   "Intel Architecture MMX Technology",
 857   "Fast Float Point Save and Restore",
 858   "Streaming SIMD extensions",
 859   "Streaming SIMD extensions 2",
 860   "Self-Snoop",
 861   "Hyper Threading",
 862   "Thermal Monitor",
 863   "",
 864   "Pending Break Enable"
 865 };
 866 
 867 const char* const VM_Version_Ext::_feature_extended_edx_id[] = {
 868   "",
 869   "",
 870   "",
 871   "",
 872   "",
 873   "",
 874   "",
 875   "",
 876   "",
 877   "",
 878   "",
 879   "SYSCALL/SYSRET",
 880   "",
 881   "",
 882   "",
 883   "",
 884   "",
 885   "",
 886   "",
 887   "",
 888   "Execute Disable Bit",
 889   "",
 890   "",
 891   "",
 892   "",
 893   "",
 894   "",
 895   "RDTSCP",
 896   "",
 897   "Intel 64 Architecture",
 898   "",
 899   ""
 900 };
 901 
 902 const char* const VM_Version_Ext::_feature_ecx_id[] = {
 903   "Streaming SIMD Extensions 3",
 904   "PCLMULQDQ",
 905   "64-bit DS Area",
 906   "MONITOR/MWAIT instructions",
 907   "CPL Qualified Debug Store",
 908   "Virtual Machine Extensions",
 909   "Safer Mode Extensions",
 910   "Enhanced Intel SpeedStep technology",
 911   "Thermal Monitor 2",
 912   "Supplemental Streaming SIMD Extensions 3",
 913   "L1 Context ID",
 914   "",
 915   "Fused Multiply-Add",
 916   "CMPXCHG16B",
 917   "xTPR Update Control",
 918   "Perfmon and Debug Capability",
 919   "",
 920   "Process-context identifiers",
 921   "Direct Cache Access",
 922   "Streaming SIMD extensions 4.1",
 923   "Streaming SIMD extensions 4.2",
 924   "x2APIC",
 925   "MOVBE",
 926   "Popcount instruction",
 927   "TSC-Deadline",
 928   "AESNI",
 929   "XSAVE",
 930   "OSXSAVE",
 931   "AVX",
 932   "F16C",
 933   "RDRAND",
 934   ""
 935 };
 936 
 937 const char* const VM_Version_Ext::_feature_extended_ecx_id[] = {
 938   "LAHF/SAHF instruction support",
 939   "Core multi-processor leagacy mode",
 940   "",
 941   "",
 942   "",
 943   "Advanced Bit Manipulations: LZCNT",
 944   "SSE4A: MOVNTSS, MOVNTSD, EXTRQ, INSERTQ",
 945   "Misaligned SSE mode",
 946   "",
 947   "",
 948   "",
 949   "",
 950   "",
 951   "",
 952   "",
 953   "",
 954   "",
 955   "",
 956   "",
 957   "",
 958   "",
 959   "",
 960   "",
 961   "",
 962   "",
 963   "",
 964   "",
 965   "",
 966   "",
 967   "",
 968   "",
 969   ""
 970 };
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="2" type="hidden" /></form></body></html>
